name: "object_avoidance_static"
description: "Reward function specifically for avoiding static objects while staying on track"
scenario: "OBJECT_AVOIDANCE_STATIC"

parameters:
  object_detection:
    safe_distance: 0.5
    warning_distance: 1.0
    critical_distance: 0.3
  steering_limits:
    max_steering: 30.0
    smooth_steering: 15.0
  rewards:
    safe_navigation: 1.5
    smooth_steering: 1.0
    progress_bonus: 2.0
    object_avoidance: 3.0
    penalty: 1e-3
  speed_control:
    safe_speed: 2.0
    slow_speed: 1.0

template: |
  # Place import statement outside of function (supported libraries: math, random, numpy, scipy, and shapely)
  import math
  import numpy as np

  def reward_function(params):
      '''
      Reward function for static object avoidance

      Available parameters from AWS DeepRacer:

      Position Parameters:
      - x (float) (meters): Agent's x-coordinate in meters
      - y (float) (meters): Agent's y-coordinate in meters
      - distance_from_center (float) (meters) [0 to track_width/2]: Distance in meters from the track center
      - is_left_of_center (boolean): Flag to indicate if the agent is on the left side of track center

      Movement Parameters:
      - speed (float) (m/s) [0 to max_speed]: Agent's speed in meters per second
      - steering_angle (float) (degrees) [-30 to 30]: Agent's steering angle in degrees
      - heading (float) (degrees) [-180 to 180]: Agent's yaw in degrees

      Track Parameters:
      - track_width (float) (meters): Width of the track
      - track_length (float) (meters): Track length in meters
      - waypoints (list_tuple): List of (x,y) coordinates as milestones along the track center
      - closest_waypoints (list_int): Indices of the two nearest waypoints

      Progress Parameters:
      - progress (float) (percentage) [0 to 100]: Percentage of track completed
      - steps (int): Number of steps completed

      Status Parameters:
      - all_wheels_on_track (boolean): Flag to indicate if the agent is on the track
      - is_crashed (boolean): Boolean flag to indicate whether the agent has crashed
      - is_offtrack (boolean): Boolean flag to indicate whether the agent has gone off track
      - is_reversed (boolean): Flag to indicate if agent is driving clockwise (True) or counter-clockwise (False)

      Objects Parameters:
      - closest_objects (list_int): Zero-based indices of the two closest objects to agent's position
      - objects_distance (list_float) (meters) [0 to track_length]: List of objects' distances in meters from starting line
      - objects_heading (list_float) (degrees) [-180 to 180]: List of objects' headings in degrees (0 for static objects)
      - objects_left_of_center (list_boolean): List of Boolean flags indicating if objects are left of center
      - objects_location (list_tuple): List of object locations as (x,y) coordinates
      - objects_speed (list_float) (m/s): List of objects' speeds in meters per second (0 for static objects)
      '''

      all_wheels_on_track = params['all_wheels_on_track']
      distance_from_center = params['distance_from_center']
      is_left_of_center = params['is_left_of_center']
      heading = params['heading']
      progress = params['progress']
      speed = params['speed']
      steering_angle = params['steering_angle']
      steps = params['steps']
      track_length = params['track_length']
      track_width = params['track_width']
      x = params['x']
      y = params['y']

      closest_waypoints = params['closest_waypoints']
      waypoints = params['waypoints']

      is_crashed = params['is_crashed']
      is_offtrack = params['is_offtrack']
      is_reversed = params['is_reversed']

      # Object parameters
      closest_objects = params['closest_objects']
      objects_distance = params['objects_distance']
      objects_heading = params['objects_heading']
      objects_left_of_center = params['objects_left_of_center']
      objects_location = params['objects_location']
      objects_speed = params['objects_speed']

      if not all_wheels_on_track or is_crashed or is_offtrack:
          return float({{parameters.rewards.penalty}})

      if is_reversed:
          return float({{parameters.rewards.penalty}})

      reward = {{parameters.rewards.safe_navigation}}

      object_risk_factor = 1.0
      closest_object_distance = float('inf')

      # Process only static objects (speed = 0)
      if objects_location and len(objects_location) > 0:
          static_object_distances = []

          for i, obj_location in enumerate(objects_location):
              obj_speed = objects_speed[i] if i < len(objects_speed) else 0.0

              # Only consider static objects
              if obj_speed <= 0.1:  # Static object (speed near 0)
                  obj_x, obj_y = obj_location
                  distance_to_obj = math.sqrt((x - obj_x)**2 + (y - obj_y)**2)
                  static_object_distances.append(distance_to_obj)

          if static_object_distances:
              closest_object_distance = min(static_object_distances)

              # Reward based on distance to closest static object - STAY AWAY FROM OBJECTS
              if closest_object_distance >= {{parameters.object_detection.warning_distance}}:
                  # Safe distance - full reward for staying away from static objects
                  reward += {{parameters.rewards.object_avoidance}}
                  object_risk_factor = 1.0
              elif closest_object_distance >= {{parameters.object_detection.safe_distance}}:
                  # Warning zone - reduced reward for being closer to objects
                  reward += {{parameters.rewards.object_avoidance}} * 0.4
                  object_risk_factor = 0.4
              elif closest_object_distance >= {{parameters.object_detection.critical_distance}}:
                  # Danger zone - minimal reward for being too close
                  reward += {{parameters.rewards.object_avoidance}} * 0.1
                  object_risk_factor = 0.1
              else:
                  # Too close to static object - major penalty
                  reward *= 0.01
                  object_risk_factor = 0.01

      # Speed control based on static object proximity
      if closest_object_distance < {{parameters.object_detection.warning_distance}}:
          if speed <= {{parameters.speed_control.slow_speed}}:
              reward += 0.5
          elif speed <= {{parameters.speed_control.safe_speed}}:
              reward += 0.3
          else:
              reward *= 0.5
      else:
          # No static objects nearby - encourage normal speed
          if speed >= {{parameters.speed_control.safe_speed}}:
              reward += 0.4

      # Steering evaluation
      abs_steering = abs(steering_angle)
      if closest_object_distance < {{parameters.object_detection.warning_distance}}:
          # Allow more steering when avoiding static objects
          if abs_steering <= {{parameters.steering_limits.max_steering}}:
              reward += {{parameters.rewards.smooth_steering}} * 0.6
      else:
          # Prefer smooth steering when clear
          if abs_steering <= {{parameters.steering_limits.smooth_steering}}:
              reward += {{parameters.rewards.smooth_steering}}
          elif abs_steering <= {{parameters.steering_limits.max_steering}}:
              reward += {{parameters.rewards.smooth_steering}} * 0.5

      # Centerline following with static object consideration
      if closest_object_distance < {{parameters.object_detection.safe_distance}}:
          # Allow more deviation when avoiding static objects
          if distance_from_center <= track_width * 0.4:
              reward += 0.3
      else:
          # Standard centerline following when clear
          if distance_from_center <= track_width * 0.25:
              reward += 0.5
          elif distance_from_center <= track_width * 0.5:
              reward += 0.2

      # Progress rewards
      if progress >= 99.0:
          reward += {{parameters.rewards.progress_bonus}} * 5
      elif progress >= 80.0:
          reward += {{parameters.rewards.progress_bonus}}

      # Efficiency calculation
      if steps > 0:
          efficiency = progress / steps
          safety_efficiency = efficiency * object_risk_factor
          reward += safety_efficiency * 0.1

      # Strategic positioning for static objects
      if objects_left_of_center and len(objects_left_of_center) > 0:
          static_objects_left = 0
          static_objects_right = 0

          for i, is_left in enumerate(objects_left_of_center):
              obj_speed = objects_speed[i] if i < len(objects_speed) else 0.0
              if obj_speed <= 0.1:  # Static object
                  if is_left:
                      static_objects_left += 1
                  else:
                      static_objects_right += 1

          # Reward for positioning away from the side with more static objects
          if static_objects_left > static_objects_right and not is_left_of_center:
              reward += 0.2
          elif static_objects_right > static_objects_left and is_left_of_center:
              reward += 0.2

      return float(reward)
